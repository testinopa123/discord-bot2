import discord
from discord.ext import commands
import os
import re
import random
import typing
from datetime import datetime, timedelta
from dotenv import load_dotenv
from discord.ui import Button, View, Select, Modal, TextInput
from typing import Optional
import asyncio
from discord import ButtonStyle, TextStyle

print("Bot script is starting...")

# Load the .env file
load_dotenv()

# Bot setup with command prefix
intents = discord.Intents.default()
intents.message_content = True
intents.guilds = True
intents.members = True

bot = commands.Bot(command_prefix=['*', '$'], intents=intents)



# Role IDs
PREMIUM_ROLE_ID = 1316416010076684478 
BLACKLIST_ROLE_ID = 1393399872912363600
LOG_CHANNEL_ID = 1390407710335307877
PROTECTED_ROLE_ID = 1396507987253657743
TICKET_CATEGORY_ID = 1394030033043062784
SUPPORT_ROLE_ID = 1394030191659188236

from asyncio import sleep

@bot.group(name='invites', invoke_without_command=True)
async def invites(ctx, user: typing.Optional[typing.Union[discord.Member, int]] = None):
    """Check invite counts for yourself or others (Management only)"""
    # Check if user is specified and if the author has Management role
    management_role = ctx.guild.get_role(1315714615396794480)
    
    if user is not None:
        if management_role not in ctx.author.roles:
            await ctx.send("❌ You need the Management role to check others' invites!")
            return
        
        if isinstance(user, int):
            user = ctx.guild.get_member(user)
            if user is None:
                await ctx.send("❌ User not found!")
                return
        
        # Format for checking others' invites
        title = f"**{user.display_name}**"
        description = f"Currently has **{await count_invites(ctx.guild, user)}** invites"
    else:
        user = ctx.author
        # Format for checking own invites
        title = f"**{user.display_name}**"
        description = f"You currently have **{await count_invites(ctx.guild, user)}** invites"

    embed = discord.Embed(
        title=title,
        description=description,
        color=0xFFA500  # Orange
    )
    await ctx.send(embed=embed)

async def count_invites(guild, user):
    """Helper function to count invites for a user"""
    try:
        invites = await guild.invites()
        return sum(invite.uses for invite in invites if invite.inviter and invite.inviter.id == user.id)
    except discord.Forbidden:
        return 0

@invites.command(name='leaderboard')
async def invites_leaderboard(ctx):
    """Show the invites leaderboard"""
    try:
        invites = await ctx.guild.invites()
    except discord.Forbidden:
        await ctx.send("❌ I don't have permission to view invites!")
        return

    # Create a dictionary to count invites per user
    invite_counts = {}
    for invite in invites:
        if invite.inviter:
            if invite.inviter.id in invite_counts:
                invite_counts[invite.inviter.id] += invite.uses
            else:
                invite_counts[invite.inviter.id] = invite.uses

    # Sort users by invite count
    sorted_invites = sorted(invite_counts.items(), key=lambda x: x[1], reverse=True)

    # Create leaderboard embed
    embed = discord.Embed(
        title="**Invites Leaderboard**",
        color=0xFFA500  # Orange
    )

    leaderboard = []
    for position, (user_id, count) in enumerate(sorted_invites[:10], start=1):
        user = ctx.guild.get_member(user_id)
        if user:
            leaderboard.append(f"{position}. **{user.display_name}** - {count} invites")

    if leaderboard:
        embed.description = "\n".join(leaderboard)
    else:
        embed.description = "No invite data available"

    await ctx.send(embed=embed)

@bot.group(name='list', invoke_without_command=True)
async def list_group(ctx):
    """List server members or roles"""
    await ctx.send("Available subcommands:\n"
                  "• `$list members` - List all server members\n"
                  "• `$list roles` - List all server roles")

@list_group.command(name='members')
async def list_members(ctx):
    """List all server members"""
    embed = discord.Embed(
        title="__**Member List**__",
        color=0xFFA500  # Orange
    )
    
    members_list = []
    for member in ctx.guild.members:
        members_list.append(f"• {member.mention} - `{member.id}`")
    
    # Split into chunks if too long
    if len(members_list) > 0:
        chunks = [members_list[i:i + 20] for i in range(0, len(members_list), 20)]
        for chunk in chunks:
            embed.add_field(name="\u200b", value="\n".join(chunk), inline=False)
    else:
        embed.description = "No members found"
    
    embed.set_footer(text=f"Total members: {len(ctx.guild.members)}")
    await ctx.send(embed=embed)

@list_group.command(name='roles')
async def list_roles(ctx):
    """List all server roles"""
    embed = discord.Embed(
        title="__**Role List**__",
        color=0xFFA500  # Orange
    )
    
    roles_list = []
    for role in sorted(ctx.guild.roles, key=lambda r: r.position, reverse=True):
        if role.name != "@everyone":
            color_hex = f"#{role.color.value:06x}" if role.color.value != 0 else "#000000"
            roles_list.append(f"• {role.mention} - `{role.id}` / {color_hex} - ({len(role.members)} members)")
    
    # Split into chunks if too long
    if len(roles_list) > 0:
        chunks = [roles_list[i:i + 10] for i in range(0, len(roles_list), 10)]
        for chunk in chunks:
            embed.add_field(name="\u200b", value="\n".join(chunk), inline=False)
    else:
        embed.description = "No roles found"
    
    embed.set_footer(text=f"Total roles: {len(ctx.guild.roles) - 1}")  # Excluding @everyone
    await ctx.send(embed=embed)

@bot.command(name='checkrole')
async def check_role(ctx, role: discord.Role):
    """Check details about a specific role"""
    color_hex = f"#{role.color.value:06x}" if role.color.value != 0 else "#000000"
    
    embed = discord.Embed(
        title="__**Role Checkup**__",
        description=f"`role color = {color_hex}` - `members = {len(role.members)}`",
        color=0xFFA500
    )
    
    # List members with this role
    members_list = []
    for member in role.members:
        members_list.append(f"• {member.mention} - `{member.id}`")
    
    if members_list:
        chunks = [members_list[i:i + 20] for i in range(0, len(members_list), 20)]
        for chunk in chunks:
            embed.add_field(name="Members with this role", value="\n".join(chunk), inline=False)
    else:
        embed.add_field(name="Members with this role", value="No members have this role", inline=False)
    
    # Create view with buttons
    view = View()
    
    # Add User button
    async def add_user_callback(interaction):
        if interaction.user != ctx.author:
            return await interaction.response.send_message("You didn't run this command!", ephemeral=True)
        
        modal = AddUserModal(role)
        await interaction.response.send_modal(modal)
    
    add_button = Button(label="Add User", style=ButtonStyle.green)
    add_button.callback = add_user_callback
    view.add_item(add_button)
    
    # Remove User button
    async def remove_user_callback(interaction):
        if interaction.user != ctx.author:
            return await interaction.response.send_message("You didn't run this command!", ephemeral=True)
        
        if not role.members:
            return await interaction.response.send_message("No members to remove!", ephemeral=True)
        
        options = [
            discord.SelectOption(label=member.display_name, value=str(member.id))
            for member in role.members
        ]
        
        select = Select(placeholder="Select member to remove", options=options)
        
        async def select_callback(interaction):
            member_id = int(select.values[0])
            member = ctx.guild.get_member(member_id)
            try:
                await member.remove_roles(role)
                await interaction.response.send_message(f"Removed {role.name} from {member.mention}", ephemeral=True)
            except Exception as e:
                await interaction.response.send_message(f"Failed to remove role: {e}", ephemeral=True)
        
        select.callback = select_callback
        remove_view = View()
        remove_view.add_item(select)
        await interaction.response.send_message("Select member to remove role from:", view=remove_view, ephemeral=True)
    
    remove_button = Button(label="Remove User", style=ButtonStyle.red)
    remove_button.callback = remove_user_callback
    view.add_item(remove_button)
    
    await ctx.send(embed=embed, view=view)

class AddUserModal(discord.ui.Modal):
    def __init__(self, role):
        super().__init__(title=f"Add User to {role.name}")
        self.role = role
        
        self.user_input = discord.ui.TextInput(
            label="User ID or Mention",
            placeholder="Enter user ID or mention",
            required=True
        )
        self.add_item(self.user_input)
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            user_input = self.user_input.value
            # Try to get member by ID
            try:
                user_id = int(user_input)
                member = interaction.guild.get_member(user_id)
            except ValueError:
                # Try to get member by mention
                if user_input.startswith('<@') and user_input.endswith('>'):
                    user_id = int(user_input[2:-1].replace('!', ''))
                    member = interaction.guild.get_member(user_id)
                else:
                    member = None
            
            if not member:
                return await interaction.response.send_message("User not found!", ephemeral=True)
            
            await member.add_roles(self.role)
            await interaction.response.send_message(f"Added {self.role.name} to {member.mention}", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"Failed to add role: {e}", ephemeral=True)

@bot.command(name='av', aliases=['avatar'])
async def avatar(ctx, user: Optional[discord.User] = None):
    """Show a user's avatar in an embed"""
    target = user or ctx.author
    
    # Get avatar URL (supports animated avatars)
    avatar_url = target.display_avatar.with_size(1024).url
    
    # Create embed
    embed = discord.Embed(
        title=f"{target.name}'s Avatar",
        color=0x2b2d31  # Discord dark theme color
    )
    embed.set_image(url=avatar_url)
    embed.set_footer(text=f"Requested by {ctx.author}", icon_url=ctx.author.display_avatar.url)
    
    await ctx.send(embed=embed)

@bot.command(name='cancel')
@commands.has_permissions(manage_messages=True)
async def cancel_session(ctx, message_id: int, *, reason: str):
    """
    Cancel an announcement with exact formatting
    Usage: $cancel <message_id> <reason>
    Example: $cancel 1234567890 No available hosts
    """
    try:
        # Fetch the original message
        try:
            message = await ctx.channel.fetch_message(message_id)
        except discord.NotFound:
            await ctx.send("Message not found. Check the message ID.", delete_after=10)
            return
        except discord.Forbidden:
            await ctx.send("Don't have permission to edit that message.", delete_after=10)
            return

        # Edit the message with exact formatting
        cancelled_content = (
            f"~~{message.content}~~\n\n"
            f"CANCELLED: {reason}"
        )
        
        # Preserve the original embed if it exists
        original_embed = message.embeds[0] if message.embeds else None
        
        await message.edit(
            content=cancelled_content,
            embed=original_embed  # Keep original embed unchanged
        )
        
        # Remove all reactions if any exist
        try:
            await message.clear_reactions()
        except:
            pass
            
        # Send confirmation (will auto-delete)
        await ctx.send(f"Announcement {message_id} has been cancelled.", delete_after=5)

    except Exception as e:
        await ctx.send(f"Error cancelling announcement: {str(e)}", delete_after=10)

@bot.command(name='announce')
@commands.has_permissions(manage_messages=True)
async def announce_session(ctx, time_input: str, *, args: str = None):
    """
    Create tournament announcement with exact host formatting
    Usage: $announce HH:MM @user1 @user2 [lobby name/number]
    Examples: 
    $announce 19:30 @Gloryy @User2 @User3 @User4
    $announce 19:30 @Gloryy Lobby 3
    """
    try:
        # Parse time input
        try:
            time_obj = datetime.strptime(time_input, "%H:%M")
        except ValueError:
            await ctx.send("Invalid time format. Use HH:MM (24h format)", delete_after=5)
            return

        # Separate users and lobby info from args
        users = []
        lobby_info = None
        
        if args:
            # Split the args into parts
            parts = args.split()
            
            # Process mentions first
            for part in parts:
                if part.startswith('<@') and part.endswith('>'):
                    # This is a mention, try to get the member
                    user_id = part[2:-1].replace('!', '')  # Remove <@ and >, and ! if present
                    try:
                        user = await commands.MemberConverter().convert(ctx, user_id)
                        users.append(user)
                    except:
                        continue
                else:
                    # Once we hit non-mention text, treat the rest as lobby info
                    lobby_start = parts.index(part)
                    lobby_info = ' '.join(parts[lobby_start:])
                    break

        # Verify at least one host
        if not users:
            await ctx.send("Please mention at least one host", delete_after=5)
            return

        # Calculate timestamps
        now = datetime.now()
        registration_time = now.replace(hour=time_obj.hour, minute=time_obj.minute, second=0)
        if registration_time < now:
            registration_time += timedelta(days=1)

        game_start_time = registration_time + timedelta(minutes=30)
        
        # Format Discord timestamps
        reg_timestamp = int(registration_time.timestamp())
        game_timestamp = int(game_start_time.timestamp())

        # Format user mentions EXACTLY as specified
        if len(users) == 1:
            hosts_text = users[0].mention
        elif len(users) == 2:
            hosts_text = f"{users[0].mention} & {users[1].mention}"
        else:
            # For 3+ hosts: "1, 2, 3 & 4"
            hosts_text = ", ".join(user.mention for user in users[:-1])
            hosts_text += f" & {users[-1].mention}"

        # Create the announcement message with optional lobby info
        announcement_msg = (
            f"@everyone\n\n"
            f"**Fortnite Tournament**{f' {lobby_info}' if lobby_info else ''}\n\n"
            f"> **Registration opens <t:{reg_timestamp}:t>**\n\n"
            f"> **First Game Commences <t:{game_timestamp}:t>**\n\n"
            f" The hosts for this session are: {hosts_text} , Direct Message them for help.\n\n"
            f"• Session lasts 3 Games. **Miss a single game and you will be banned.**\n"
            f"• Required at least **110+ Reacts**"
        )
        
        # Send the announcement
        message = await ctx.send(announcement_msg)
        
        # Add reaction emoji
        try:
            await message.add_reaction("✋")
        except:
            pass

        # Delete the command message
        try:
            await ctx.message.delete()
        except:
            pass

    except Exception as e:
        await ctx.send(f"Error creating announcement: {str(e)}", delete_after=10)

@bot.command(name='ghost')
@commands.has_permissions(manage_messages=True)
async def ghost_ping(ctx, user: discord.Member, amount: int = 20):
    """
    Ghost ping a user X times (default: 20)
    Usage: $ghost @user [amount]
    """
    # Validate amount
    if amount < 1:
        await ctx.send("Amount must be at least 1", delete_after=3)
        return
    if amount > 50:  # Safety limit
        amount = 50
        await ctx.send("Capped at 50 pings for safety", delete_after=3)

    try:
        # Delete command message
        await ctx.message.delete()
    except:
        pass

    # Send confirmation that will self-destruct
    confirm = await ctx.send(
        f"Ghost pinging {user.mention} {amount} times... (this will self-destruct)",
        delete_after=3
    )

    # Send and delete pings
    successful_pings = 0
    for i in range(amount):
        try:
            # Random slight delay to avoid detection (0.1-0.5s)
            await asyncio.sleep(random.uniform(0.1, 0.5))
            
            msg = await ctx.send(user.mention)
            await msg.delete()
            successful_pings += 1
        except Exception as e:
            continue

    # Optional: Send final report that self-destructs
    if successful_pings > 0:
        report = await ctx.send(
            f"Successfully ghost pinged {user.mention} {successful_pings}/{amount} times (this will self-destruct)",
            delete_after=3
        )
        
class TicketCreationView(View):
    def __init__(self):
        super().__init__(timeout=None)
        
    @discord.ui.button(label="Create Ticket", style=discord.ButtonStyle.green, custom_id="create_ticket")
    async def create_ticket(self, interaction: discord.Interaction, button: Button):
        # Check if user already has an open ticket
        category = interaction.guild.get_channel(TICKET_CATEGORY_ID)
        for channel in category.channels:
            if isinstance(channel, discord.TextChannel) and f"support-{interaction.user.name.lower()}" in channel.name.lower():
                await interaction.response.send_message(
                    f"You already have an open ticket: {channel.mention}",
                    ephemeral=True
                )
                return
        
        # Generate random 5-digit number
        random_number = random.randint(10000, 99999)
        
        # Create clean username for channel name (discord's channel name requirements)
        clean_username = ''.join(c for c in interaction.user.name.lower() if c.isalnum() or c in ('-', '_'))
        clean_username = clean_username[:20]  # Limit length
        
        # Create ticket channel name
        channel_name = f"support-{clean_username}-{random_number}"
        
        # Create overwrites
        overwrites = {
            interaction.guild.default_role: discord.PermissionOverwrite(read_messages=False),
            interaction.user: discord.PermissionOverwrite(read_messages=True, send_messages=True),
            interaction.guild.me: discord.PermissionOverwrite(read_messages=True, send_messages=True)
        }
        
        # Add support role if it exists
        support_role = interaction.guild.get_role(SUPPORT_ROLE_ID)
        if support_role:
            overwrites[support_role] = discord.PermissionOverwrite(read_messages=True, send_messages=True)
        
        # Create the channel
        try:
            ticket_channel = await category.create_text_channel(
                name=channel_name,
                overwrites=overwrites,
                reason=f"Ticket created by {interaction.user}"
            )
        except discord.HTTPException as e:
            await interaction.response.send_message(
                f"Failed to create ticket channel: {str(e)}",
                ephemeral=True
            )
            return
        
        # Send initial message
        embed = discord.Embed(
            title=f"Support Ticket - {interaction.user}",
            description=(
                "Support will be with you shortly. Please describe your issue.\n\n"
                "**Ticket Info:**\n"
                f"- User: {interaction.user.mention}\n"
                f"- Created: <t:{int(datetime.now().timestamp())}:F>\n"
                f"- Ticket ID: {random_number}"
            ),
            color=0x00FF00
        )
        
        view = TicketManagementView()
        await ticket_channel.send(
            content=f"{interaction.user.mention} {support_role.mention if support_role else ''}",
            embed=embed,
            view=view
        )
        
        await interaction.response.send_message(
            f"Ticket created: {ticket_channel.mention}",
            ephemeral=True
        )

class TicketManagementView(View):
    def __init__(self):
        super().__init__(timeout=None)
        
    @discord.ui.button(label="Close Ticket", style=discord.ButtonStyle.red, custom_id="close_ticket")
    async def close_ticket(self, interaction: discord.Interaction, button: Button):
        # Remove user's access to the channel
        for user in interaction.channel.overwrites:
            if isinstance(user, discord.Member) and user != interaction.guild.me:
                await interaction.channel.set_permissions(
                    user,
                    read_messages=False,
                    send_messages=False
                )
        
        # Disable the button
        button.disabled = True
        button.label = "Ticket Closed"
        button.style = discord.ButtonStyle.grey
        
        await interaction.response.edit_message(view=self)
        
        embed = discord.Embed(
            title="Ticket Closed",
            description=f"This ticket was closed by {interaction.user.mention}",
            color=0xFF0000
        )
        await interaction.channel.send(embed=embed)
        
    @discord.ui.button(label="Delete Ticket", style=discord.ButtonStyle.danger, custom_id="delete_ticket")
    async def delete_ticket(self, interaction: discord.Interaction, button: Button):
        if not any(role.id == SUPPORT_ROLE_ID for role in interaction.user.roles):
            await interaction.response.send_message("Only support staff can delete tickets.", ephemeral=True)
            return
            
        await interaction.response.send_message("Deleting this ticket in 5 seconds...")
        await asyncio.sleep(5)
        await interaction.channel.delete(reason=f"Ticket deleted by {interaction.user}")

class TicketModal(Modal):
    def __init__(self, channel: discord.TextChannel):
        super().__init__(title="Edit Ticket")
        self.channel = channel
        self.name = TextInput(
            label="New Channel Name",
            placeholder="Enter new channel name...",
            default=channel.name,
            required=True
        )
        self.topic = TextInput(
            label="New Channel Topic",
            placeholder="Enter new channel topic...",
            default=channel.topic or "",
            style=discord.TextStyle.long,
            required=False
        )
        self.add_item(self.name)
        self.add_item(self.topic)
    
    async def on_submit(self, interaction: discord.Interaction):
        try:
            await self.channel.edit(
                name=self.name.value,
                topic=self.topic.value,
                reason=f"Ticket edited by {interaction.user}"
            )
            await interaction.response.send_message("Ticket updated successfully!", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"Failed to update ticket: {str(e)}", ephemeral=True)

@bot.command(name="ticketsetup")
@commands.has_permissions(administrator=True)
async def setup_tickets(ctx):
    """Setup the ticket system in this channel"""
    embed = discord.Embed(
        title="Support Tickets",
        description="Click the button below to create a new support ticket",
        color=0x00FF00
    )
    
    await ctx.send(embed=embed, view=TicketCreationView())
    await ctx.message.delete()

@bot.command(name="ticket")
async def ticket_command(ctx):
    """Create a support ticket"""
    # This just directs users to use the button
    await ctx.send("Please use the ticket button in the support channel to create a ticket.")

@bot.command(name="editticket")
@commands.has_permissions(manage_channels=True)
async def edit_ticket(ctx):
    """Edit the current ticket's name and topic"""
    if not ctx.channel.name.startswith("ticket-"):
        await ctx.send("This is not a ticket channel!")
        return
    
    modal = TicketModal(ctx.channel)
    await ctx.interaction.response.send_modal(modal)

@bot.command(name="adduser")
@commands.has_permissions(manage_channels=True)
async def add_to_ticket(ctx, member: discord.Member):
    """Add a user to the current ticket"""
    if not ctx.channel.name.startswith("ticket-"):
        await ctx.send("This is not a ticket channel!")
        return
    
    await ctx.channel.set_permissions(
        member,
        read_messages=True,
        send_messages=True
    )
    
    await ctx.send(f"Added {member.mention} to this ticket")

@bot.command(name="removeuser")
@commands.has_permissions(manage_channels=True)
async def remove_from_ticket(ctx, member: discord.Member):
    """Remove a user from the current ticket"""
    if not ctx.channel.name.startswith("ticket-"):
        await ctx.send("This is not a ticket channel!")
        return
    
    await ctx.channel.set_permissions(
        member,
        overwrite=None
    )
    
    await ctx.send(f"Removed {member.mention} from this ticket")

@bot.command(name="closeticket")
async def close_ticket(ctx):
    """Close the current ticket"""
    if not ctx.channel.name.startswith("ticket-"):
        await ctx.send("This is not a ticket channel!")
        return
    
    # Find the close button in the ticket's first message
    async for message in ctx.channel.history(limit=1, oldest_first=True):
        if message.components:  # If the message has components (buttons)
            for component in message.components:
                if isinstance(component, Button) and component.custom_id == "close_ticket":
                    # Simulate clicking the close button
                    view = TicketManagementView()
                    await view.close_ticket(ctx.interaction, component)
                    return
    
    # If no button found, close manually
    for user in ctx.channel.overwrites:
        if isinstance(user, discord.Member) and user != ctx.guild.me:
            await ctx.channel.set_permissions(
                user,
                read_messages=False,
                send_messages=False
            )
    
    embed = discord.Embed(
        title="Ticket Closed",
        description=f"This ticket was closed by {ctx.author.mention}",
        color=0xFF0000
    )
    await ctx.send(embed=embed)

@bot.command(name="deleteticket")
@commands.has_permissions(manage_channels=True)
async def delete_ticket(ctx):
    """Delete the current ticket (staff only)"""
    if not ctx.channel.name.startswith("ticket-"):
        await ctx.send("This is not a ticket channel!")
        return
    
    await ctx.send("Deleting this ticket in 5 seconds...")
    await asyncio.sleep(5)
    await ctx.channel.delete(reason=f"Ticket deleted by {ctx.author}")

@bot.command(name='status')
@commands.has_permissions(administrator=True)
async def set_status(ctx, activity_type: str = "playing", *, message: str):
    """Change the bot's status with different activity types
    Usage: $status <type> <message>
    Types: playing|streaming|listening|watching|competing"""
    
    # Convert activity type
    activity_types = {
        "playing": discord.Game(name=message),
        "streaming": discord.Streaming(name=message, url="https://twitch.tv/yourchannel"),
        "listening": discord.Activity(type=discord.ActivityType.listening, name=message),
        "watching": discord.Activity(type=discord.ActivityType.watching, name=message),
        "competing": discord.Activity(type=discord.ActivityType.competing, name=message)
    }
    
    try:
        activity = activity_types.get(activity_type.lower(), discord.Game(name=message))
        await bot.change_presence(activity=activity)
        
        embed = discord.Embed(
            title="✅ Status Updated",
            description=f"Now {activity_type.lower()} **{message}**",
            color=0x00FF00
        )
        await ctx.send(embed=embed)
        
    except Exception as e:
        error_embed = discord.Embed(
            title="❌ Status Update Failed",
            description=f"```{str(e)}```\nValid types: playing, streaming, listening, watching, competing",
            color=0xFF0000
        )
        await ctx.send(embed=error_embed)

@bot.command(name='gloryy')
async def gloryy_command(ctx):
    """Displays info about Gloryy"""
    embed = discord.Embed(
        title="Who's Gloryy?",
        description="Gloryy is a random guy from Germany, he's really chill!",
        color=0x1a9f1a  # Green color
    )
    await ctx.send(embed=embed)

@bot.command(name='say')
@commands.has_permissions(manage_messages=True)
async def say_command(ctx, channel: typing.Optional[discord.TextChannel], *, message: str):
    """Make the bot repeat your message in a specific channel
    Usage: $say <#channel> <message> or $say <message>"""
    try:
        await ctx.message.delete()
    except discord.Forbidden:
        pass
    
    target = channel or ctx.channel
    await target.send(message)

@bot.group(name='editrole', invoke_without_command=True)
async def editrole(ctx):
    """Role editing commands"""
    await ctx.send("Available subcommands:\n"
                  "• `$editrole name <role> <newname>` - Rename a role\n"
                  "• `$editrole color <role> <color>` - Change a role's color\n"
                  "• `$editrole new <name> [color]` - Create a new role\n"
                  "• `$editrole del <role>` - Delete a role")
    
@editrole.command(name='color')
async def change_role_color(ctx, role: typing.Union[discord.Role, int], color: discord.Color):
    """Change a role's color
    Examples:
    $editrole color @Moderator #FF0000
    $editrole color 123456789 0x00FF00
    $editrole color Admin discord.Color.blue()
    """
    if isinstance(role, int):
        role = ctx.guild.get_role(role)
        if role is None:
            await ctx.send("❌ Role not found")
            return

    if not ctx.guild.me.guild_permissions.manage_roles:
        await ctx.send("❌ I don't have permission to manage roles")
        return

    if role.position >= ctx.guild.me.top_role.position:
        await ctx.send("❌ I can't modify this role (hierarchy)")
        return

    try:
        old_color = role.color
        await role.edit(color=color)
        embed = discord.Embed(
            title="✅ Role Color Changed",
            description=f"Changed color for role {role.mention}",
            color=color
        )
        embed.add_field(name="Old Color", value=str(old_color))
        embed.add_field(name="New Color", value=str(color))
        await ctx.send(embed=embed)
    except Exception as e:
        await ctx.send(f"❌ Failed to change role color: {str(e)}")

@editrole.command(name='name')
async def rename_role(ctx, role: typing.Union[discord.Role, int], *, new_name: str):
    """Rename an existing role"""
    if isinstance(role, int):
        role = ctx.guild.get_role(role)
        if role is None:
            await ctx.send("❌ Role not found")
            return

    if not ctx.guild.me.guild_permissions.manage_roles:
        await ctx.send("❌ I don't have permission to manage roles")
        return

    if role.position >= ctx.guild.me.top_role.position:
        await ctx.send("❌ I can't modify this role (hierarchy)")
        return

    try:
        old_name = role.name
        await role.edit(name=new_name)
        embed = discord.Embed(
            title="✅ Role Renamed",
            description=f"Changed role name from `{old_name}` to `{new_name}`",
            color=0x00FF00
        )
        await ctx.send(embed=embed)
    except Exception as e:
        await ctx.send(f"❌ Failed to rename role: {str(e)}")

@editrole.command(name='new')
async def create_role(ctx, name: str, color: typing.Optional[discord.Color] = None):
    """Create a new role with optional color
    Example:
    $editrole new Moderator
    $editrole new VIP #FF0000
    $editrole new Admin 0x00FF00
    $editrole new Staff discord.Color.blue()"""
    if not ctx.guild.me.guild_permissions.manage_roles:
        await ctx.send("❌ I don't have permission to manage roles")
        return

    try:
        # Create role with optional color
        role = await ctx.guild.create_role(name=name, color=color)
        
        embed = discord.Embed(
            title="✅ Role Created",
            description=f"Created new role: {role.mention}",
            color=role.color if color else 0x00FF00
        )
        if color:
            embed.add_field(name="Color", value=str(color))
        await ctx.send(embed=embed)
    except Exception as e:
        await ctx.send(f"❌ Failed to create role: {str(e)}")

@editrole.command(name='del')
async def delete_role(ctx, role: typing.Union[discord.Role, int]):
    """Delete a role"""
    if isinstance(role, int):
        role = ctx.guild.get_role(role)
        if role is None:
            await ctx.send("❌ Role not found")
            return

    if not ctx.guild.me.guild_permissions.manage_roles:
        await ctx.send("❌ I don't have permission to manage roles")
        return

    if role.position >= ctx.guild.me.top_role.position:
        await ctx.send("❌ I can't delete this role (hierarchy)")
        return

    try:
        role_name = role.name
        await role.delete()
        embed = discord.Embed(
            title="✅ Role Deleted",
            description=f"Deleted role: `{role_name}`",
            color=0x00FF00
        )
        await ctx.send(embed=embed)
    except Exception as e:
        await ctx.send(f"❌ Failed to delete role: {str(e)}")

@bot.command(name='role')
async def role_command(ctx, user: typing.Union[discord.Member, int], *, role_input: str):
    """Assign or remove a role from a user"""
    # Handle user input
    if isinstance(user, int):
        try:
            user = await ctx.guild.fetch_member(user)
        except discord.NotFound:
            await ctx.send("❌ User not found in this server")
            return
    
    # Handle role input
    remove_role = role_input.startswith('-')
    role_name_or_id = role_input[1:] if remove_role else role_input
    
    # Try to get role by ID first
    if role_name_or_id.isdigit():
        role = ctx.guild.get_role(int(role_name_or_id))
    else:
        # Try to get role by mention or name
        if role_name_or_id.startswith('<@&') and role_name_or_id.endswith('>'):
            role_id = int(role_name_or_id[3:-1])
            role = ctx.guild.get_role(role_id)
        else:
            role = discord.utils.get(ctx.guild.roles, name=role_name_or_id)
    
    if role is None:
        await ctx.send("❌ Role not found in this server")
        return
    
    # Check bot permissions
    if not ctx.guild.me.guild_permissions.manage_roles:
        await ctx.send("❌ I don't have permission to manage roles")
        return
    
    # Check role hierarchy
    if role.position >= ctx.guild.me.top_role.position:
        await ctx.send("❌ I can't manage this role (hierarchy)")
        return
    
    try:
        if remove_role:
            if role not in user.roles:
                await ctx.send(f"❌ {user.mention} doesn't have the {role.mention} role")
                return
            await user.remove_roles(role, reason=f"Removed by {ctx.author}")
            action = "removed"
            color = 0xFFA500  # Orange for removal
        else:
            if role in user.roles:
                await ctx.send(f"❌ {user.mention} already has the {role.mention} role")
                return
            await user.add_roles(role, reason=f"Added by {ctx.author}")
            action = "given"
            color = 0x00FF00  # Green for addition
        
        # Create success embed
        embed = discord.Embed(
            title="✅ Role Assignment",
            description=f"Successfully {action} {role.mention} to {user.mention}",
            color=color
        )
        embed.set_footer(text=f"Action performed by {ctx.author}")
        
        await ctx.send(embed=embed)
        
    except discord.Forbidden:
        await ctx.send("❌ I don't have permission to manage this role")
    except Exception as e:
        await ctx.send(f"❌ An error occurred: {str(e)}")

@bot.command(name='purge')
@commands.has_permissions(manage_messages=True)  # Requires message management permissions
async def purge_messages(ctx, amount: int):
    """
    Deletes a specified number of messages in the current channel
    Usage: *purge <number> (max 100 at a time)
    """
    # Validate the amount
    if amount <= 0:
        await ctx.send("Please specify a positive number of messages to delete.", delete_after=5)
        return
    
    # Set a reasonable limit (Discord's API limit is 100)
    if amount > 100:
        amount = 100
        await ctx.send("Maximum purge amount is 100. Deleting 100 messages...", delete_after=3)
    
    try:
        # Delete the command message first
        await ctx.message.delete()
        
        # Bulk delete messages
        deleted = await ctx.channel.purge(limit=amount)
        
        # Send confirmation (will auto-delete)
        confirm = await ctx.send(f"Deleted {len(deleted)} messages.", delete_after=3)
        
    except discord.Forbidden:
        await ctx.send("I don't have permissions to delete messages here.", delete_after=5)
    except discord.HTTPException as e:
        await ctx.send(f"Error deleting messages: {e}", delete_after=5)

@bot.command(name='ping_H')
async def ping_horrible_command(ctx):
    """Returns simulated poor connection metrics"""
    # Simulated poor values
    base_latency = 950
    jitter = random.randint(50, 150)
    packet_loss = random.uniform(8.0, 15.0)
    
    # Create professional-looking embed
    embed = discord.Embed(
        title="Network Performance Report",
        color=0xFFA500  # Orange color for warning
    )
    
    # Add technical fields
    embed.add_field(
        name="Latency",
        value=f"{base_latency}ms ± {jitter}ms",
        inline=True
    )
    embed.add_field(
        name="Packet Loss",
        value=f"{packet_loss:.1f}%",
        inline=True
    )
    embed.add_field(
        name="Region",
        value="EU-West (High Load)",
        inline=True
    )
    
    # Technical issues
    issues = [
        f"Network congestion detected (Load: {random.randint(85, 98)}%)",
        f"Route instability to {random.choice(['AMS', 'FRA', 'PAR'])} backbone",
        "Peering capacity limits reached",
        f"Hardware utilization at {random.randint(90, 100)}% capacity"
    ]
    
    embed.add_field(
        name="Identified Issues",
        value="\n- " + "\n- ".join(issues),
        inline=False
    )
    
    # Status with technical severity
    status_levels = [
        ("Degraded Performance", "Service available with reduced quality"),
        ("Capacity Warning", "Approaching operational limits"),
        ("Critical Load", "Immediate attention recommended")
    ]
    status, description = random.choice(status_levels)
    
    embed.add_field(
        name=f"Status: {status}",
        value=description,
        inline=False
    )
    
    # Professional footer
    embed.set_footer(text=f"Requested by {ctx.author.display_name} | Diagnostic ID: {random.randint(10000, 99999)}")
    
    await ctx.send(embed=embed)

@bot.command(name='ping')
async def ping_command(ctx):
    """Check the bot's latency and connection status"""
    # Calculate latency in milliseconds
    latency_ms = round(bot.latency * 1000)
    
    # Create the embed
    embed = discord.Embed(
        title="***__PONG!__***",
        color=0xFFA500  # Orange color
    )
    
    # Add fields to the embed
    embed.add_field(
        name="**Current MS**",
        value=f"{latency_ms}ms",
        inline=False
    )
    embed.add_field(
        name="**Ping**",
        value=f"{latency_ms}ms",
        inline=False
    )
    embed.add_field(
        name="**Region**",
        value="EU",
        inline=False
    )
    
    # Determine if there are any known issues
    known_issues = "None"
    if latency_ms > 200:
        known_issues = "High latency detected"
    elif latency_ms > 500:
        known_issues = "Severe latency issues"
    
    embed.add_field(
        name="**Known issues**",
        value=known_issues,
        inline=False
    )
    embed.add_field(
        name="**Status**",
        value="Online and functional",
        inline=False
    )
    
    # Set footer with current timestamp
    embed.set_footer(text=f"Requested by {ctx.author.name}")
    
    await ctx.send(embed=embed)

class RoleManagementView(discord.ui.View):
    def __init__(self, member, premium_role, has_role=False, original_message=None):
        super().__init__(timeout=300)
        self.member = member
        self.premium_role = premium_role
        self.has_role = has_role
        self.original_message = original_message
        if has_role:
            self.add_item(RemoveRoleButton())
            self.add_item(DoNothingButton())
        else:
            self.add_item(CustomButton())
            self.add_item(DoNothingButton())

class RemoveRoleButton(discord.ui.Button):
    def __init__(self):
        super().__init__(label="REMOVE ROLE", style=discord.ButtonStyle.secondary)
    
    async def callback(self, interaction: discord.Interaction):
        view = self.view
        try:
            await view.member.remove_roles(view.premium_role, reason=f"Role removed by {interaction.user}")
            await view.original_message.delete()
            await interaction.response.send_message(
                f"✅ Role removed from {view.member.mention}",
                delete_after=10
            )
        except discord.Forbidden:
            await interaction.response.send_message("❌ Permission denied", ephemeral=True)
        except Exception as e:
            await interaction.response.send_message(f"❌ Error: {str(e)}", ephemeral=True)

class ClaimRewardView(discord.ui.View):
    def __init__(self, member, premium_role, guild, expiration_timestamp, original_reason=None, original_interaction=None):
        super().__init__(timeout=None)
        self.member = member
        self.premium_role = premium_role
        self.guild = guild
        self.expiration_timestamp = expiration_timestamp
        self.original_reason = original_reason
        self.original_interaction = original_interaction
        self.add_item(ClaimRewardButton())

class ClaimRewardButton(discord.ui.Button):
    def __init__(self):
        super().__init__(label="Claim reward", style=discord.ButtonStyle.success, custom_id="claim_reward_button")
    
    async def callback(self, interaction: discord.Interaction):
        view = self.view
        
        self.disabled = True
        self.style = discord.ButtonStyle.secondary
        self.label = "Claimed ✓"
        await interaction.response.edit_message(view=view)
        
        current_timestamp = int(datetime.now().timestamp())
        
        if current_timestamp > view.expiration_timestamp:
            await interaction.followup.send("Failed to redeem the reward | **expired**", ephemeral=True)
            return
        
        try:
            if view.premium_role in view.member.roles:
                await interaction.followup.send("You've already claimed this reward!", ephemeral=True)
                return
                
            await view.member.add_roles(view.premium_role, reason="Premium role claimed by user")
            
            success_embed = discord.Embed(
                description="✅ Reward has been successfully redeemed",
                color=0x00CED1
            )
            await interaction.followup.send(embed=success_embed)
            
            log_channel = view.guild.get_channel(LOG_CHANNEL_ID)
            if log_channel:
                reason = view.original_reason if view.original_reason else "No reason provided"
                claim_embed = discord.Embed(
                    title="**Reward Claimed**",
                    color=0x00FF00,
                    timestamp=datetime.now()
                )
                claim_embed.add_field(name="User", value=f"{view.member.mention} ~ `{view.member.id}`", inline=False)
                claim_embed.add_field(name="Date", value=f"<t:{current_timestamp}:F>", inline=False)
                claim_embed.add_field(name="Reason", value=reason, inline=False)
                
                if view.original_interaction:
                    staff_member = view.original_interaction.user
                    claim_embed.add_field(name="Staff", value=f"{staff_member.mention} ~ `{staff_member.id}`", inline=False)
                
                await log_channel.send(embed=claim_embed)
                
        except discord.Forbidden:
            await interaction.followup.send("Failed to redeem the reward | **permission error**", ephemeral=True)
        except Exception as e:
            await interaction.followup.send(f"Failed to redeem the reward | **error**: {str(e)}", ephemeral=True)

class CustomButton(discord.ui.Button):
    def __init__(self):
        super().__init__(label="CUSTOM", style=discord.ButtonStyle.secondary)
    
    async def callback(self, interaction: discord.Interaction):
        modal = CustomReasonModal(
            self.view.member, 
            self.view.premium_role, 
            interaction, 
            interaction.guild,
            self.view.original_message
        )
        await interaction.response.send_modal(modal)

class DoNothingButton(discord.ui.Button):
    def __init__(self):
        super().__init__(label="DO NOTHING", style=discord.ButtonStyle.secondary)
    
    async def callback(self, interaction: discord.Interaction):
        try:
            await self.view.original_message.delete()
        except:
            pass
        await interaction.response.send_message("Action cancelled", ephemeral=True)

class CustomReasonModal(discord.ui.Modal):
    def __init__(self, member, premium_role, original_interaction, guild, original_message):
        super().__init__(title="Custom Premium Role Assignment")
        self.member = member
        self.premium_role = premium_role
        self.original_interaction = original_interaction
        self.guild = guild
        self.original_message = original_message
        self.reason_input = discord.ui.TextInput(
            label="Reason",
            placeholder="Enter the reason for giving premium role...",
            max_length=200,
            required=True
        )
        self.add_item(self.reason_input)

    async def on_submit(self, interaction: discord.Interaction):
        reason = self.reason_input.value
        try:
            expiration_date = datetime.now() + timedelta(hours=48)
            expiration_timestamp = int(expiration_date.timestamp())
            embed = discord.Embed(title="Premium Access", description=reason, color=0x2b2d31)
            embed.add_field(name="Expiration Date:", value=f"<t:{expiration_timestamp}:F>", inline=False)
            embed.add_field(name="", value="This is an automated message sent from TEST101.", inline=False)
            
            claim_view = ClaimRewardView(
                self.member, 
                self.premium_role, 
                self.guild, 
                expiration_timestamp,
                original_reason=reason,
                original_interaction=self.original_interaction
            )
            
            try:
                await self.member.send(embed=embed, view=claim_view)
                dm_status = "Reward DM sent"
            except discord.Forbidden:
                dm_status = "Could not send DM"
            
            try:
                await self.original_message.delete()
            except:
                pass
            
            await interaction.response.send_message(
                content=f"Premium reward sent to {self.member.mention} | **reason** ~ {reason}",
                delete_after=None
            )
            
        except Exception as e:
            await interaction.response.send_message(content=f"❌ Error: {str(e)}")

class PremiumListView(discord.ui.View):
    def __init__(self, premium_members, protected_role_id):
        super().__init__(timeout=300)
        self.premium_members = premium_members
        self.protected_role_id = protected_role_id
        self.add_item(CancelRolesButton())

class CancelRolesButton(discord.ui.Button):
    def __init__(self):
        super().__init__(label="CANCEL ROLES", style=discord.ButtonStyle.secondary)
    
    async def callback(self, interaction: discord.Interaction):
        # Disable the button immediately
        self.disabled = True
        self.label = "✓ ROLES CANCELLED"
        self.style = discord.ButtonStyle.grey
        
        view = self.view
        guild = interaction.guild
        premium_role = guild.get_role(PREMIUM_ROLE_ID)
        protected_role = guild.get_role(view.protected_role_id)
        
        if not premium_role:
            await interaction.response.edit_message(view=view)
            await interaction.followup.send("❌ Premium role not found", ephemeral=True)
            return
        
        results = []
        await interaction.response.edit_message(view=view)
        
        for member_data in view.premium_members:
            member = guild.get_member(member_data['id'])
            if member:
                if protected_role and protected_role in member.roles:
                    results.append(f"🚫 Skipped {member.mention} | **protected user**")
                    continue
                
                try:
                    await member.remove_roles(premium_role, reason="Mass role removal by admin")
                    results.append(f"✅ Removed **premium** role from {member.mention}")
                except discord.Forbidden:
                    results.append(f"❌ Failed to remove role from {member.mention} | **missing permissions**")
                except Exception as e:
                    results.append(f"❌ Failed to remove role from {member.mention} | **error: {str(e)}**")
        
        result_message = "\n".join(results)
        if len(result_message) > 2000:
            result_message = result_message[:1990] + "\n[...]"
        
        embed = discord.Embed(
            title="Premium Role Removal Results",
            description=result_message,
            color=0xFFA500
        )
        await interaction.followup.send(embed=embed)

@bot.command(name='premium')
async def pizza_command(ctx, user_id: str = None):
    if user_id is None:
        await ctx.send("❌ Please provide a user ID. Usage: `*premium <user_id>`")
        return
    
    user_id = user_id.strip('"\'')
    if not re.match(r'^\d{17,19}$', user_id):
        await ctx.send(f"❌ Invalid user ID: {user_id}")
        return
    
    try:
        user_id_int = int(user_id)
        guild = ctx.guild
        member = await guild.fetch_member(user_id_int)
        
        blacklist_role = guild.get_role(BLACKLIST_ROLE_ID)
        if blacklist_role and blacklist_role in member.roles:
            embed = discord.Embed(
                description=f"Failed to give Premium access to {member.mention}.\n\nUser is BLACKLISTED from getting premium features.",
                color=0xFF0000
            )
            await ctx.send(embed=embed)
            return
            
        premium_role = guild.get_role(PREMIUM_ROLE_ID)
        
        if not premium_role:
            await ctx.send("❌ Premium role not found")
            return
        
        if premium_role.position >= guild.me.top_role.position:
            await ctx.send("❌ Role hierarchy error")
            return
        
        has_role = premium_role in member.roles
        view = RoleManagementView(member, premium_role, has_role=has_role, original_message=ctx.message)
        
        if has_role:
            msg = await ctx.send(f"{member.mention} already has **premium** role", view=view)
        else:
            msg = await ctx.send(f"Role **premium** selected for {member.mention}", view=view)
            
    except Exception as e:
        await ctx.send(f"❌ Error: {str(e)}")

@bot.command(name='bl')
async def blacklist_command(ctx, user: discord.Member = None, *, reason: str = None):
    if user is None or reason is None:
        await ctx.send("❌ Usage: `$bl @user <reason>`")
        return
    
    guild = ctx.guild
    blacklist_role = guild.get_role(BLACKLIST_ROLE_ID)
    premium_role = guild.get_role(PREMIUM_ROLE_ID)
    
    if not blacklist_role:
        await ctx.send("❌ Blacklist role not found")
        return
    
    if blacklist_role.position >= guild.me.top_role.position:
        await ctx.send("❌ Role hierarchy error")
        return
    
    if blacklist_role in user.roles:
        await ctx.send(f"{user.mention} is already blacklisted")
        return
    
    if premium_role and premium_role in user.roles:
        try:
            await user.remove_roles(premium_role, reason=f"Automatically removed when blacklisted by {ctx.author}")
        except discord.Forbidden:
            await ctx.send("⚠️ Could not remove premium role (missing permissions)")
    
    await user.add_roles(blacklist_role, reason=f"Blacklisted by {ctx.author}: {reason}")
    embed = discord.Embed(
        description=f"{user.mention} has been successfully **BLACKLISTED**\n\n### Reason\n\n-# {reason}",
        color=0xFFFF00)
    
    if premium_role and premium_role in user.roles:
        embed.add_field(name="Premium Status", value="✅ Premium role was automatically removed", inline=False)
    
    await ctx.send(embed=embed)
    
    try:
        dm_embed = discord.Embed(
            description=f"Hello {user.mention},\n\nyou have been ***blacklisted*** from test898\n\n**reason** - {reason}\n\n-# This action is not reversable so do not dm any staff member",
            color=0xFF0000)
        await user.send(embed=dm_embed)
    except:
        pass

@bot.command(name='bll')
async def blacklist_lookup_command(ctx, user: discord.Member = None):
    if user is None:
        await ctx.send("❌ Usage: `$bll @user`")
        return
    
    blacklist_role = ctx.guild.get_role(BLACKLIST_ROLE_ID)
    if not blacklist_role:
        await ctx.send("❌ Blacklist role not found")
        return
    
    if blacklist_role in user.roles:
        await ctx.send(f"{ctx.author.mention}, {user.mention} is **blacklisted**")
    else:
        await ctx.send(f"no **blacklist** data has been found for {user.mention}")

@bot.command(name='prem')
async def list_premium_members(ctx):
    premium_role = ctx.guild.get_role(PREMIUM_ROLE_ID)
    protected_role = ctx.guild.get_role(PROTECTED_ROLE_ID)
    
    if not premium_role:
        embed = discord.Embed(
            title="Failed | No Roles Found",
            description="The premium role doesn't exist in this server",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return
    
    premium_members = []
    for member in ctx.guild.members:
        if premium_role in member.roles:
            premium_members.append({
                'id': member.id,
                'mention': member.mention,
                'is_protected': protected_role in member.roles if protected_role else False
            })
    
    if not premium_members:
        embed = discord.Embed(
            title="Failed | No Roles Found",
            description="No users currently have the premium role",
            color=0xFF0000
        )
        await ctx.send(embed=embed)
        return
    
    description_lines = ["__**Premium Users**__\n"]
    for member in premium_members:
        if member['is_protected']:
            description_lines.append(f"•**{member['mention']}** ~ `{member['id']}` __***(no kick)***__")
        else:
            description_lines.append(f"•**{member['mention']}** ~ `{member['id']}`")
    
    embed = discord.Embed(
        title="__**Premium Users**__",
        description="\n".join(description_lines),
        color=0xFFA500
    )
    
    view = PremiumListView(premium_members, PROTECTED_ROLE_ID)
    await ctx.send(embed=embed, view=view)

@bot.event
async def on_command_error(ctx, error):
    if isinstance(error, commands.CommandNotFound):
        return
    elif isinstance(error, commands.MissingRequiredArgument):
        await ctx.send("❌ Missing argument.")
    elif isinstance(error, commands.BadArgument):
        await ctx.send("❌ Invalid argument.")
    else:
        await ctx.send(f"❌ Error: {str(error)}")

def main():
    token = 'MTM5MzYwMTEzMDU3OTIzNDg5Ng.GpYFxL.mbDxHEEcn1cCVa4Yfsi9ZXTZtZoZeLuVdfYO88'
    if not token:
        print("❌ DISCORD_BOT_TOKEN not found in environment variables.")
        return
    
    try:
        bot.run(token)
    except discord.LoginFailure:
        print("❌ Invalid bot token.")
    except Exception as e:
        print(f"❌ Error starting bot: {e}")

if __name__ == "__main__":
    main()